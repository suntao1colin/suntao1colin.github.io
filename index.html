<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="孙涛的个人博客" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="孙涛的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="星辰大海">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="星辰大海">
<meta property="og:description" content="孙涛的个人博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="星辰大海">
<meta name="twitter:description" content="孙涛的个人博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>星辰大海</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">星辰大海</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/21/page2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="colin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/21/page2/" itemprop="url">pthon 笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-21T10:11:27+08:00">
                2017-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Python是一种适合开发应用程序的高级编程语言。Python又被称为”胶水语言”。<br>Python的哲学是简单，优雅，高效。<br>一、简介</p>
<p>Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。<br>二、python基础语法</p>
<p>Python是大小写敏感的。<br>Python使用严格的缩进来表示代码的逻辑关系，请务必坚持约定俗成的习惯，坚持使用4个空格缩进。<br>1、python的数据类型</p>
<p>整数<br>python可以处理任意大小的整数，包括负整数，在程序上的写法和数学上的写法完全相同。<br>浮点数<br>浮点数也就是小数，之所以称为浮点数，是因为在科学计数法表示时，浮点数的小数点位置是可变的。<br>整数和浮点数在计算机内部的存储方式是不同的，整数运算是精确的，而浮点数运算是有四舍五入的。<br>字符串<br>字符串是以单引号‘或者双引号“括起来的任意文本。<br>布尔值<br>布尔值和布尔代数完全一致，一个布尔值只有true或者False两种值。<br>布尔值可以进行and、or和not运算。<br>空值<br>空值是python中的一个特殊值，用None来表示。<br>2、变量和常量</p>
<p>变量<br>在计算机的程序中，变量不仅可以是数字，还可以是任意的数据类型。<br>变量在程序中用变量名来表示，变量名必须是大小写英文、数字和__来表示，且不能用数字来开头。<br>等号是赋值语句，可以把任意数值类型赋值给变量。同一变量可以反复赋值，而且可以是不同类型变量<br>这种变量类型不固定的语言称之为动态语言，与之对应的是静态语言。<br>静态语言在变量赋值时必须指定变量的类型，如赋值是类型不匹配就会报错。Java是静态语言。<br>常量<br>所谓的常量就是不能变的变量，比如常用的数学常数π就是一个常量。<br>在python中，通常用全部大写的变量名来表示常量。例如：PI=3.14159265359<br>3、列表和元祖</p>
<p>list(列表)<br>list是python中一个有序的集合，可以随时添加和删除元素。如：L=[a,b,c]<br>获得list元素的个数：len()函数<br>list是可变对象<br>往list中追加元素到末尾：<br>appen()方法<br>把元素插入到指定的位置：<br>insert(index,element)<br>从list中删除元素：<br>pop()方法<br>空列表表示法：<br>L=[] ,len(L)=0<br>tuple(元祖）<br>tuple是python中一个有序的表，但是tuple一旦初始化就不能再修改。如：t=(1,2)<br>tuple是不可变的，所以代码更加安全。<br>空元祖表示法：<br>t=()<br>4、条件判断</p>
<p>if…else<br>语法：<br>if(条件语句）:<br>条件成立时执行代码<br>else:<br>条件不成立时执行代码<br>if…elif…else<br>语法<br>if(条件语句）:<br>条件1成立时执行代码<br>elif:<br>条件2成立时执行代码<br>else:<br>条件不成立时执行代码<br>5、循环语句</p>
<p>for…in循环<br>示例：<br>list=[1,2,3]<br>for x in lsit:<br>print(x)<br>可以依次把list或者tuple中元素迭代出来。<br>range()函数：<br>可以生成一个整数序列，再通过list()函数转化为list列表。<br>while循环<br>语法：<br>while(循环条件成立时）:<br>执行循环语句<br>在循环中，可以用break语句提前退出循环。<br>在循环过程中，也可以通过continue语句，跳过当前循环，直接进行下一次循环。<br>6、dict和set</p>
<p>dict<br>dict是python中内置的字典，使用键值对（key-value)存储，有极快的查找速度。<br>dict中的key是不可变对象。<br>示例<br>d={‘Michael:95′,’Bob’:75,’Tom’:60}<br>d[‘Michael’]<br>dict中的get()方法：如果key不存在，则返回None；如果key存在，则返回指定的value。<br>哈希算法：通过key值计算value的存储位置的算法。<br>set<br>set和dict类似，也是一组key的集合，但不存储value。在set中，key不能重复。<br>set和dict的唯一区别仅在于没有存储对应的value。<br>三、python函数</p>
<p>1、定义函数</p>
<p>定义一个函数，用def语句，依次写出函数名、括号、括号中的参数和冒号 :，然后，在缩进块中编写函数体，函数的返回值用return语句返回。<br>示例：<br>def my_abs():<br>if x&gt;0:<br>return x<br>else:<br>return -x<br>定义函数时，要先确定函数名和参数个数。如果有必要，可以先对函数的数据类型做检查。<br>空函数：定义一个空函数，用pass语句。<br>示例：<br>def nop():<br>pass<br>pass为一个占位符。缺少了pass，程序可能报错。<br>函数体内可以用return语句随时返回函数结果。<br>函数执行完毕也没有return语句时，自动返回return none。<br>函数可以返回多个值，但其实就是一个tuple。<br>2、函数的参数</p>
<p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。<br>默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！<br>要注意定义可变参数和关键字参数的语法：<br><em>args是可变参数，args接收的是一个tuple；<br>**kw是关键字参数，kw接收的是一个dict。<br>以及调用函数时如何传入可变参数和关键字参数的语法：<br>可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过</em>args传入：func(<em>(1, 2, 3))；<br>关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过<strong>kw传入：func(</strong>{‘a’: 1, ‘b’: 2})。<br>使用</em>args和<em>*kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。<br>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。<br>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符</em>，否则定义的将是位置参数。<br>3、递归函数</p>
<p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。<br>示例：<br>计算阶乘 n! = 1 x 2 x 3 x … x n，用函数fact(n)表示<br>def fact(n):<br>if n=1:<br>return 1<br>return n*fact(n-1)<br>使用递归函数的优点是逻辑简单清晰，理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。缺点是过深的调用会导致栈溢出。<br>针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。<br>Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。<br>4、函数的高级特性</p>
<p>切片(slice)<br>取一个list或tuple的部分元素。<br>迭代(Iteration)<br>遍历一个list或者tuple，通过for…in来遍历。<br>默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。<br>列表生成式（List Comprehensions）是Python内置的非常简单却强大可以用来创建list的生成式。<br>举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))。<br>生成器(generator)<br>generator是非常强大的工具，在Python中，可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator。<br>要理解generator的工作原理，它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束。<br>请注意区分普通函数和generator函数，普通函数调用直接返回结果：</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = abs(6) &gt;&gt;&gt; r 6<br>generator函数的“调用”实际返回一个generator对象：<br>g = fib(6) &gt;&gt;&gt; g <generator object="" fib="" at="" 0x1022ef948=""><br>迭代器(Iterator)<br>凡是可作用于for循环的对象都是Iterable类型；<br>凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；<br>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。<br>Python的for循环本质上就是通过不断调用next()函数实现的，例如：<br>for x in [1, 2, 3, 4, 5]: pass<br>实际上完全等价于：<br>首先获得Iterator对象: it = iter([1, 2, 3, 4, 5]) # 循环: while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break<br>5、函数式编程</generator></p>
</blockquote>
</blockquote>
</blockquote>
<p>函数式编程可以归结到面向过程的程序设计，但是其思想更加贴近于数学计算。<br>由于python允许使用变量，因此python不是纯函数式编程语言。<br>高阶函数<br>把函数作为参数传入，这样的函数即被称为高阶函数。函数式编程就是这种高度抽象的编程范式。<br>一个最简单的高阶函数<br>def add(x,y,f)<br>return f(x)+f(y)<br>map函数<br>map()函数是 Python 内置的高阶函数.<br>它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。<br>示例：<br>def f(x):<br>return x*x #定义了一个平方函数<br>print map(f,[1,2,3,4,5,6,7,8,9])<br>输出结果<br>[1,4,9,16,25,36,49,64,81]<br>reduce函数<br>reduce()函数也是Python内置的一个高阶函数。<br>reduce()函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。<br>示例：<br>def f(x,y)<br>return x+y #定义了一个求和函数<br>调用reduce(f,[1,3,5,7,9])，reduce函数的计算结果为25。<br>上述计算即对list的所有元素进行求和。<br>reduce()还可以第三个可选参数，作为计算的初始值。<br>调用reduce(f,[1,3,5,7,9],100)，reduce函数的计算结果为125。<br>filter函数<br>python内建的filter高阶函数用于过滤序列。<br>filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。<br>示例：<br>def is_odd(x):<br>return x%2==1 #定义了一个判断奇数的函数，删除偶数，保留奇数<br>filter(is_odd,[1,4,6,7,9,12,17])<br>输出结果<br>[1,7,9,17]<br>sort函数<br>sort()函数是一个高阶函数，它可以接收一个key函数来实现自定义排序。<br>示例：</p>
<blockquote>
<blockquote>
<blockquote>
<p>sort([36,5,-12,9,-21],key=abs)<br>[5,9,-12,-21,36]<br>对字符串的排序，默认是按照ASCLL大小来比较的。<br>用sorted()排序的关键在于实现一个映射函数。<br>返回函数<br>python中高阶函数除了可以接受函数作为参数之外，还可以把函数作为结果返回。<br>闭包（Closure）<br>像这种内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为闭包。<br>闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。<br>匿名函数(lambda)<br>关键字lambda表示匿名函数，冒号前面的x表示函数参数。<br>匿名函数lambda x: x <em> x，实际上是：<br>def f(x):<br>return x</em>x<br>Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。<br>装饰器(decorator)<br>本质上，decorator就是一个返回函数的高阶函数。<br>在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。<br>decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。<br>偏函数<br>当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。<br>四、python模块和包</p>
</blockquote>
</blockquote>
</blockquote>
<p>模块（Module）<br>在python中，一个.py文件称为一个模块。<br>使用模块最大的好处就是可以提高代码的可维护性。<br>包（Package）<br>为了避免模块名冲突，python中又引入了按目录来组织模块的方法，称之为包。<br>引入模块<br>比如导入sys模块，即<br>import sys<br>安装第三方模块<br>在python中，安装第三方模块，通过安装包管理工具pip完成。<br>五、python面向对象编程</p>
<p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。<br>数据封装、继承和多态是面向对象的三大特点。<br>类（class）<br>类是一种抽象的模板。<br>实例（instance)<br>实例是根据类创造出来的一个个具体的对象。<br>各个实例拥有的数据都互相独立，互不影响。<br>方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据。<br>通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。<br>数据封装<br>面向对象编程的一个重要特点就是数据封装。<br>数据封装，通过类定义访问数据的函数，调用实例的方法，即可操作对象内部的数据。<br>继承<br>子类class可以获得父类class的全部变量的类型和方法。<br>继承最大的好处就是实现了代码的重用。<br>多态<br>多态是面向对象语言的一个基本特性，多态意味着变量并不知道引用的对象是什么，根据引用对象的不同表现不同的行为方式。<br>获取对象的信息<br>type()：判断对象的类型<br>isinstance()：判断class的类型<br>dir()：获得一个对象的所有属性和方法，它返回一个包含字符串的list。<br>实例属性和类属性<br>由于Python是动态语言，根据类创建的实例可以任意绑定属性。<br>在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。<br>面向对象高级编程<br>使用<strong>slots</strong><br>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<strong>slots</strong>变量，来限制该class实例能添加的属性：<br>class Student(object): <strong>slots</strong> = (‘name’, ‘age’) # 用tuple定义允许绑定的属性名称<br>使用@property<br>Python内置的@property装饰器就是负责把一个方法变成属性调用的。<br>@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。<br>多重继承<br>由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。<br>MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。<br>只允许单一继承的语言（如Java）不能使用MixIn的设计。<br>定制类<br><strong>str</strong>:返回一个字符串<br><strong>iter</strong>：返回一个迭代对象<br><strong>getitem</strong>：按照下标取出元素<br><strong>getattr</strong>：动态调用属性<br><strong>call</strong>：直接调用实例的属性和方法<br>枚举类<br>Enum为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。<br>@unique装饰器可以帮助我们检查保证没有重复值。<br>Enum可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较。<br>元类<br>metaclass是Python中非常具有魔术性的对象，它可以改变类创建时的行为。这种强大的功能使用起来务必小心。<br>metaclass，直译为元类，简单的解释就是：<br>当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。<br>但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。<br>连接起来就是：先定义metaclass，就可以创建类，最后创建实例。<br>所以，metaclass允许你创建类或者修改类。你可以把类看成是metaclass创建出来的“实例”。<br>六、IO编程</p>
<p>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。<br>七、进程和线程</p>
<p>对于操作系统来说，一个任务就是一个进程（Process）。<br>在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。<br>线程是最小的执行单元，而进程由至少一个线程组成。<br>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。<br>多任务的实现有3种方式：<br>多进程模式；<br>多线程模式；<br>多进程+多线程模式。<br>Python既支持多进程，又支持多线程。<br>八、网络编程</p>
<p>1、TCP/IP协议</p>
<p>IP地址：每台计算机的唯一标识的地址。<br>端口：计算机用来识别网络程序的标识。<br>TCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。<br>许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等。<br>一个IP包除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。<br>2、TCP编程（socket）</p>
<p>用TCP协议进行Socket编程在Python中十分简单，对于客户端，要主动连接服务器的IP和指定端口，对于服务器，要首先监听指定端口，然后，对每一个新的连接，创建一个线程或进程来处理。通常，服务器程序会无限运行下去。<br>3、UDP编程</p>
<p>TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。<br>使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。<br>虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/21/page1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="colin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/21/page1/" itemprop="url">JS 笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-21T10:01:19+08:00">
                2017-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Javascript是世界上目前最流行的脚本语言，是一种可以运行在浏览器中的解释型编程语言。</p>
<p>一、简介</p>
<p>1、JavaScript的历史</p>
<p>在1995年，由网景公司的Brendan Eich用两周时间设计出来的，起初是为了给静态的HTML增加一些动态的效果。<br>由于当时的Java非常火，所以网景公司希望借Java的名气来帮助推广。<br>JavaScript和Java除了语法上有点像以外，其他方面并没有什么联系。<br>简单地说，Java和Javascript的关系其实好比雷锋和雷锋塔的关系。<br>2、ECMAScript</p>
<p>简单说，ECMAScript是JavaScript语言的一种标准，大多数是说到ECMAScript可以替代JavaScript。<br>3、JavaScript的版本</p>
<p>目前最新的版本为ECMAScript标准（简称ES6)已经于2015年6月正式发布，如果浏览器环境仅支持ES5标准，可以用Babel转码器将ES6代码转为ES5代码。<br>二、基本语法</p>
<p>JavaScript语法和Java相似，每个语句以;结束，语句块用{…}。<br>JavaScript的变量是弱类型的，对大小写敏感，变量命名遵循驼峰规则。<br>注释：一种为单行注释，用//起头；一种是多行注释，放在/<em>和</em>/之间。<br>1、数据类型</p>
<p>包含Number,,Boolean,Object，String,Udefined和Null，一共6种。<br>而typeof返回的值有6种可能，分别为Number,Boolean,String,Object,Function和Undefined。<br>ES6中引入一种新的原始数据类型Symbol,表示独一无二的值。symbol通过symbol函数生成。<br>Number<br>JavaScript不区分整数（integer)和浮点数(float)，统一用Number来表示。<br>Number可以直接进行四则运算，规则和数学上一致。<br>*特殊类型<br>NaN;//NaN表示Not a number,当无法计算结果时用NaN来表示<br>Infinity;//Infinity表示无限大，当数值超过JavaScript的Number所表示的最大值时。<br>Boolean<br>布尔值表示逻辑运算值，只有true和false两种值。<br>String<br>字符串是可以用单引号或者双引号括起来的任意文本。<br>Object<br>JavaScript中的对象是一组由键值对组成的无序集合。<br>Funciton<br>JavaScript是一种面向对象的语言，Function表示方法。（在面向过程的语言中，Function表示函数）<br>Undefined<br>undefined表示未定义，用于判断函数参数是否传递的情况下使用。<br>Null<br>null表示一个空的值，大多数情况下为用null。<br>2、变量</p>
<p>JavaScript是一种动态类型的语言，变量的类型没有限制，可以赋予各种类型的值。<br>变量在程序中不只可以是数字，还可以是任意的数据类型。<br>变量在JavaScript中用一个变量名来表示，变量名是大小写英文、数字、$和__的组合，且不能用数字开头。变量名也不能是JavaScript的关键字。<br>在JavaScript中，申明一个变量用var语句，使用=对变量进行赋值。<br>同一个变量可以反复赋值，而且可以是不同类型的变量，但是只能用var申明一次。<br>var a=1;//申明了变量a，此时a的值为undefined<br>var b=’hello world’;//定义申明了变量b，给变量b赋值了一个字符串<br>var c=null;//c的值为null，空值<br>3、字符串</p>
<p>JavaScript中的字符串是用’ ‘和” “来表示的。<br>转义字符：\n表示换行，\t表示制表符，\表示的字符就是\。<br>ES6新增多行字符表示法，用’…’来表示：<br>‘这是一个<br>多行<br>字符串’<br>模板字符串：<br>要把多个字符串连接起来，用+来连接。<br>var name=’Tom’;<br>var age=’20’;<br>var message=’你好,’+name+’你今年’+age+’岁了?’;<br>alert(message）；<br>ES6新增模板字符串，它会自动替换字符串中的变量。<br>var name=’Tom’;<br>var age=’20’;<br>var message=’你好,${name},你今年${age}岁了？’;<br>alert(message）；<br>操作字符串：<br>获得某字符串的长度。<br>var s=”hello world”;<br>s.length;<br>获取字符串某个位置的字符串，通过索引值index来操作，索引号从0开始。<br>var s=”hello,world”;<br>s[0];//’h’<br>s[1];//’e’<br>s[13];//undefined<br>toUpperCase()<br>把一个字符串全部变为大写。<br>var s=”hello”;<br>s.toUpperCase();//返回“HELLO”<br>toLowerCase()<br>把一个字符串全部变为小写。<br>var s=”Hello”;<br>var lower=s.toLowerCase();<br>lower;//”hello”<br>indexOf()<br>搜索指定字符串出现的位置，返回索引值。<br>var s=”hello, world”;<br>s.indexOf(world);//返回7<br>s.indexOf(World);//没有找到指定字符串，返回-1<br>substring()<br>返回指定索引区间的子串。<br>var s=”hello, world”;<br>s.substring(0,5);//从索引0开始到5（不包含5），返回”hello”<br>s.substring(7);//从索引7开始到结束，返回“world”<br>4、数组（array)</p>
<p>数组是一组按照次序排列的值，可以包含任意的数据类型，通过索引来访问每个元素。<br>数组本质上是一类特殊的对象。typeof运算符返回数组的类型是object。<br>数组的遍历可以用for…in循环来遍历，也可以用for/while循环和数组的foreach方法。<br>for循环遍历数组<br>var a=[1,2,3];<br>for(var i=0;i&lt;a.length;i++){<br>console.log(a[i]);<br>}<br>length属性<br>要取得数组的长度，直接访问length属性。<br>var arr=[1,2,3];<br>arr.length;//3<br>数组的length属性是可写的，人为更改数组length属性或者更改数组元素可以导致数组变化。<br>indexOf<br>与String相似，Array也可以通过indexOf()来搜索一个指定元素的位置。<br>var arr=[10,20,’30’,”xyz”];<br>arr.indexOf(10);//元素10的索引为0<br>arr.indexOf(20);//元素20的索引为1<br>arr.indexOf(30);//元素30的索引没找到，返回-1<br>arr.indexOf(’30’);//元素’30’的索引为2<br>slice<br>slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array。<br>var arr=[‘A’,’B’,’C’,’D’,’E’,’F’];<br>arr.slice(0,3);//从索引0开始，到索引3结束，但是不包括3 [‘A’,’B’,’C’]<br>arr.slice(3);//从索引3开始到结束 [‘D’,’E’,’F’]<br>注意到slice()的起止参数包括开始索引，但是不包括结束索引。<br>如果不给slice()传递任何参数，它就会从头到尾截取元素。利用这一点，可以很容易复制一个Array。<br>push和pop<br>push()向Array末尾添加若干元素，pop()把Array的最后一个元素删除掉。<br>var arr=[1,2];<br>arr.push(‘A’,’B’);<br>arr;//[1,2,’A’,’B’]<br>arr.pop();<br>arr;//[1,2,’A’]<br>unshift和shift<br>如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉<br>var arr=[1,2];<br>arr.unshift(‘A’,’B’);<br>arr;//[‘A’,’B’,1,2]<br>arr.shift();<br>arr;//[‘B’,1,2]<br>sort<br>sort()可以对Array进行排序，它会直接修改当前Array的元素位置，按照默认位置排序<br>var arr=[‘B’,’C’,’A’]<br>arr.sort();<br>arr;//[‘A’,’B’,’C’]<br>reverse<br>reverse()把整个Array的元素反转<br>var arr=[‘one’,’two’,’three’];<br>arr.reverse();<br>arr;//[‘three’,’two’,’one’]<br>splice<br>splice()方法是修改Array中修改Array的“万能方法”，它可以从指定的索引删除若干元素，也可以从该位置添加若干元素<br>concat<br>concat()把当前的Array和另一个Array连接起来，并返回一个新的Array。<br>var arr=[‘A’,’B’,’C’];<br>var added=arr.concat([1,2,3]);<br>added;//[‘A’,’B’,’C’,1,2,3]<br>arr;//[‘A’,’B’,’C’]<br>join<br>join()方法是一个非常实用的方法，把当前Array中的每个元素都有指定的字符串连接起来，然后返回连接的字符串<br>var arr=[‘A’,’B’,’C’,1,2,3];<br>arr.join(‘-‘);//A-B-C-1-2-3<br>5、对象（Object)</p>
<p>对象是JavaScript中一种无序的集合类型，由若干的键值对（key-value)组成。<br>var obj={<br>p1:’hello’,<br>p2:’world’<br>};<br>属性：表示对象的每一个键名。同时它的键值可以是任意的数据类型。<br>方法：如果一个属性的值为函数，通常把这个属性称为方法。它可以像函数一样被调用。<br>6、条件判断</p>
<p>（1）if语句</p>
<p>if语句是基于条件成立才执行相应代码时使用的语句。<br>语法：<br>if(条件) { 条件成立时执行代码}<br>（2）if…else语句</p>
<p>if…else语句是在指定的条件成立时执行代码，在条件不成立时执行else后的代码。<br>语法:<br>if(条件) { 条件成立时执行的代码} else {条件不成立时执行的代码}<br>（3）if..else嵌套语句</p>
<p>要在多组语句中选择一组来执行，使用if..else嵌套语句。<br>语法:<br>if(条件1) { 条件1成立时执行的代码} else if(条件2) { 条件2成立时执行的代码} … else if(条件n) { 条件n成立时执行的代码} else { 条件1、2至n不成立时执行的代码}<br>（4）Switch语句</p>
<p>当有很多种选项的时候，switch比if else使用更方便。<br>语法:<br>switch(表达式) { case值1: 执行代码块 1 break; case值2: 执行代码块 2 break; … case值n: 执行代码块 n break; default: 与 case值1 、 case值2…case值n 不同时执行的代码 }<br>三元运算符<br>JavaScript还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断。<br>这个三元运算符可以被视为if…else…的简写形式，因此可以用于多种场合。<br>7、循环</p>
<p>（1）while循环</p>
<p>while循环重复执行一段代码，直到某个条件不再满足。<br>while语句结构：<br>while(判断条件) { 循环语句 }<br>（2）for循环</p>
<p>for循环和while循环相似。<br>for循环结构：<br>for(初始化表达式;测试表达式;递增表达式) {       循环语句  }<br>初始化表达式（initialize）：确定循环的初始值，只在循环开始时执行一次。<br>测试表达式（test）：检查循环条件，只要为真就进行后续操作。<br>递增表达式（increment）：完成后续操作，然后返回上一步，再一次检查循环条件。<br>（3）do…while循环</p>
<p>它和while循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件。<br>do…while语句结构：<br>do {     循环语句 } while(判断条件)<br>用do { … } while()循环要小心，循环体会至少执行1次，而for和while循环则可能一次都不执行。<br>（4）break语句和continue语句</p>
<p>break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。<br>break语句用于跳出代码块或循环。<br>for循环也可以使用break语句跳出循环。<br>continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。<br>（5）for… in循环</p>
<p>for…in循环不仅可以遍历对象，也可以遍历数组，毕竟数组是一种特殊的对象。<br>遍历对象<br>var o={<br>name:’Jack’,<br>age:20,<br>city:”Beijing”<br>};<br>for(var key in o){<br>console.log(key);<br>}<br>遍历数组<br>var a=[1,2,3];<br>for(var i in a){<br>console.log(a[i]);<br>}<br>8、ES6新增数据类型</p>
<p>Map:<br>Map是一组键值对的结构，具有极快的查找速度。<br>初始化Map需要一个二维数组，或者直接初始化一个空Map。<br>Set:（无序）<br>Set它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>Set本身是一个构造函数，用来生成Set数据结构。<br>Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。<br>Iterator（遍历器）<br>Iterator接口主要用于for…of循环来遍历。<br>9、函数</p>
<p>函数的声明的三种方法：<br>（1）function命令</p>
<p>function print(s){<br>console.log(s);<br>}<br>print();<br>（2）函数表达式</p>
<p>var print=function(s){<br>console.log(s);<br>}<br>print();<br>（3）Function构造函数</p>
<p>var add=new Function(<br>‘x’,<br>‘y’,<br>‘return x+y’<br>);<br>return语句<br>return语句所带的表达式就是函数的返回值，终止函数的运行。<br>return语句不是必需的，如果没有return语句的话，函数的返回值为undefined。<br>函数的参数<br>函数运行的时候，需要外部数据，不同外部数据会输出不同结果，这些外部叫做参数。<br>函数的参数不是必需的，是可以省略的。被省略的参数的值变为undefined。<br>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。<br>但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。<br>arguments对象<br>arguments对象包含了函数运行时所有的参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。<br>arguments对象除了可以读取参数，还可以为参数赋值（严格模式不允许这种用法）。<br>可以通过arguments对象的length属性，判断函数调用时到底带几个参数。<br>10、作用域</p>
<p>作用域指的是变量存在的范围。<br>JavaScript中有两种作用域，一种是全局作用域，变量在整个程序中一直存在，所有地方均可以读取；另一种是函数作用域，变量只在函数内部存在。<br>全局变量：在函数外部声明的变量，它可以在函数内部读取。<br>局部变量：在函数内部定义的变量，它在函数外部无法读取。<br>注：函数内部定义的变量，会在该作用域覆盖同名的全局变量。<br>由于JavaScript中函数可以嵌套，此时内部函数可以访问外部函数定义的变量，反之则不行。<br>ES6新增let和const<br>块级作用域<br>ES6中新增let命令，用来声明变量。它的用法类似于var，但是所声明的变量，仅在let命令的代码块内有效。<br>ES6中明确在块级作用域内可以声明函数，但是函数声明语句在块级作用域范围外不可引用。<br>let命令<br>let命令不像var那样会出现“变量提升”的现象。所以，变量一定要在声明后使用，否则会报错。<br>let不允许在同一个块级作用域内，重复声明同一变量。<br>for循环技术器，适合使用let命令。<br>for(let i=0;i<10;i++){} console.log(i);="" const命令="" const命令声明一个只读的常量。一旦声明，常量的值就不可发生改变。="" const声明的变量不得改变值。const一旦声明变量，就必须立即初始化，不能留到以后赋值。="" const的作用域与let相同：只在声明的块级作用域内有效。="" const命令声明的常量也是不提升，只在声明的位置后使用。="" const命令声明的常量，和let命令一样不可重复声明。="" 变量提升="" 与全局作用域相同，函数作用域内部的变量也会产生“变量提升”的现象。即var声明的变量，无论在什么位置，都会被提升到函数整体的顶部。="" 闭包（closure)="" 定义在一个函数内部的函数。闭包是能够读取其他函数内部变量的函数。="" 本质上闭包是连接函数内部和外部的一座桥梁。="" 闭包的好处：="" 一个是可以读取函数内部的变量，另一个是让这些变量始终保持在内存中。="" 闭包的另一个用处是封装对象的私有属性和私有方法。="" 闭包的注意事项：="" 1、由于闭包会使函数的变量保存在内存中，内存消耗较大，滥用闭包会造成网页的性能问题，甚至是内存泄露。="" 2、闭包会在父函数的外部，改变父函数内部的变量的值。="" this的用法="" this是javascript中的一个关键字。代指调用的那个对象。="" 它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。="" 箭头函数（="" arrow="" function)="" 箭头函数是es6新增的函数。="" 箭头函数相当于匿名函数，简化了函数的定义。="" x="">x<em>x;<br>上面的箭头函数相当于<br>function (x){<br>return x</em>x;<br>}<br>普通的function函数的和箭头函数的区别是，箭头函数没有它自己的this值，箭头函数的this值继承自外围作用域。<br>箭头函数不可以当做构造函数，也就是说不可以使用new命令，否则会抛出一个错误。<br>箭头函数不可以使用arguments对象，该对象在函数体内不存在。<br>箭头函数不可以使用yield命令 ，因此不能用作generator函数。<br>generator（生成器）<br>generator和函数有点像，但可以返回多次。<br>定义<br>function<em> foo(x){<br>yield x+1;<br>yield x+2;<br>return x+3;<br>}<br>generator和函数不同的是，generator由function</em>定义，并且除return语句，还可以yield返回多次。<br>generator的好处<br>一是可以实现记住执行状态的功能，这个需要面向对象才能实现的功能。<br>二是可以把异步回调函数的代码变成“同步”代码。<br>三、面向对象编程</10;i++){}></p>
<p>面向对象编程（OOP）的核心是把真实世界中的发杂关系抽象成一个个对象，然后由对象之间的分工合作来实现对真实世界的模拟。<br>面向过程编程是由一系列函数和指令来组成，而面向对象的程序由一系列对象来组成。<br>典型的面向对象编程语言（Java，C++），存在类和实例的两个概念。<br>类：类是对象的类型模板。<br>实例：实例是根据类创造的对象。<br>而JavaScript的面向对象是基于构造函数（constructor)和原型链（prototype)l来实现的。<br>原型<br>每个对象都会在其内部初始化一个属性，就是prototype(原型）。<br>prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。<br>原型链<br>对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain）。<br>如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性指向的那个对象。<br>继承</p>
<p>对象之间继承有多种方法。<br>1、构造函数的继承</p>
<p>使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象上的构造函数上加上一行。<br>2、使用prototype属性</p>
<p>function Parent(){<br>this.name = ‘wang’;<br>}<br>function Child(){<br>this.age = 28;<br>}<br>Child.prototype = new Parent();//继承了Parent，通过原型</p>
<p>var demo = new Child();<br>alert(demo.age);<br>alert(demo.name);//得到被继承的属性<br>作用域链<br>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找， 直至全局函数，这种组织形式就是作用域链。<br>class<br>E6中引入了class类的概念，作为对象的模板。<br>//定义类<br>class Point {<br>constructor(x, y) {<br>this.x = x;<br>this.y = y;<br>}<br>toString() {<br>return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’;<br>}<br>}<br>生成类的实例对象的方法，用new命令。<br>class的继承<br>class之间可以通过extends关键字来继承。<br>class ColorPoint extends Point {<br>constructor(x, y, color) {<br>super(x, y); // 调用父类的constructor(x, y)<br>this.color = color;<br>}<br>toString() {<br>return this.color + ‘ ‘ + super.toString(); // 调用父类的toString()<br>}<br>}<br>四、浏览器</p>
<p>1、BOM</p>
<p>window<br>window对象表示浏览器的窗口。<br>window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。<br>navigator<br>navigator对象表示浏览器的信息，最常用属性包括：<br>navigator.appName：浏览器名称；<br>navigator.appVersion：浏览器版本；<br>navigator.language：浏览器设置的语言；<br>navigator.platform：操作系统类型；<br>navigator.userAgent：浏览器设定的User-Agent字符串。<br>screen<br>screen对象表示屏幕的信息，常用的属性有：<br>screen.width：屏幕宽度，以像素为单位；<br>screen.height：屏幕高度，以像素为单位；<br>screen.colorDepth：返回颜色位数，如8、16、24。<br>location<br>location对象表示当前页面的URL信息,也可以用可以用location.href获取。<br>要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，调用location.reload()方法非常方便。<br>document<br>document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。<br>要查找DOM树的某个节点，需要从document对象开始查找。最常用的查找是根据ID和Tag Name。<br>用document对象提供的getElementById()和getElementsByTagName()可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点。<br>document对象还有一个cookie属性，可以获取当前页面的Cookie。<br>JavaScript可以通过document.cookie读取到当前页面的Cookie。<br>history<br>history对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。<br>2、DOM</p>
<p>DOM是JavaScript操作网页的接口，全称为“文档对象模型”（Document Object Model）。<br>它的作用是将网页转为一个JavaScript对象，从而可以用脚本进行各种操作（比如增删内容）。<br>HTML的DOM树</p>
<p>节点父、子和同胞的关系</p>
<p> （1）创建新节点<br>createAttribute();//创建属性节点<br>createElement();//创建一个具体的元素<br>createTextNode();//创建一个文本节点<br>（2）添加、移除、替换、插入<br>appendChild();//添加节点<br>removeChild();//移出节点<br>replaceChild();//替换节点<br>insertBefore();//在已有的子节点前插入一个新的子节点<br>（3）查找<br>getElementsByTagName(); //通过标签名称<br>getElementsByName(); //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)<br>getElementById(); //通过元素Id，唯一性<br>（4）更新<br>getAttribute() //返回指定的属性值<br>setAttribute() //把指定属性设置或修改为指定的值<br>.innerHTML //改变元素的内容<br>事件（event)</p>
<p>事件是异步编程的实现方式，本质上程序各个部分之间的通信。<br>DOM事件的两种操作，一种为监听，一种为触发。<br>通用事件的监听函数<br>// event(事件)工具集<br>markyun.Event = {<br>// 页面加载完成后<br>readyEvent : function(fn) {<br>if (fn==null) {<br>fn=document;<br>}<br>var oldonload = window.onload;<br>if (typeof window.onload != ‘function’) {<br>window.onload = fn;<br>} else {<br>window.onload = function() {<br>oldonload();<br>fn();<br>};<br>}<br>},<br>// 视能力分别使用dom0||dom2||IE方式 来绑定事件<br>// 参数： 操作的元素,事件名称 ,事件处理程序<br>addEvent : function(element, type, handler) {<br>if (element.addEventListener) {<br>//事件类型、需要执行的函数、是否捕捉<br>element.addEventListener(type, handler, false);<br>} else if (element.attachEvent) {<br>element.attachEvent(‘on’ + type, function() {<br>handler.call(element);<br>});<br>} else {<br>element[‘on’ + type] = handler;<br>}<br>},<br>// 移除事件<br>removeEvent : function(element, type, handler) {<br>if (element.removeEventListener) {<br>element.removeEventListener(type, handler, false);<br>} else if (element.datachEvent) {<br>element.detachEvent(‘on’ + type, handler);<br>} else {<br>element[‘on’ + type] = null;<br>}<br>},<br>// 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)<br>stopPropagation : function(ev) {<br>if (ev.stopPropagation) {<br>ev.stopPropagation();<br>} else {<br>ev.cancelBubble = true;<br>}<br>},<br>// 取消事件的默认行为<br>preventDefault : function(event) {<br>if (event.preventDefault) {<br>event.preventDefault();<br>} else {<br>event.returnValue = false;<br>}<br>},<br>// 获取事件目标<br>getTarget : function(event) {<br>return event.target || event.srcElement;<br>},<br>// 获取event对象的引用，取到事件的所有信息，确保随时能使用event；<br>getEvent : function(e) {<br>var ev = e || window.event;<br>if (!ev) {<br>var c = this.getEvent.caller;<br>while (c) {<br>ev = c.arguments[0];<br>if (ev &amp;&amp; Event == ev.constructor) {<br>break;<br>}<br>c = c.caller;<br>}<br>}<br>return ev;<br>}<br>};<br>通用事件的触发<br>1、鼠标事件<br>鼠标单击和双击事件：onclick、dbclick<br>鼠标移入和移出事件：onmouseover和onmouseout<br>鼠标按钮点击点击时和松开时：onmousedown和onmouseup<br>2、键盘事件<br>keydown：按下键盘时触发该事件。<br>keypress：只要按下的键并非Ctrl、Alt、Shift和Meta，就接着触发keypress事件。<br>keyup：松开键盘时触发该事件<br>AJAX<br>ajax的全称：Asynchronous Javascript And XML。 异步传输+js+xml。 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。<br>创建一个AJAX<br>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象 (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息 (3)设置响应HTTP请求状态变化的函数 (4)发送HTTP请求 (5)获取异步调用返回的数据 (6)使用JavaScript和DOM实现局部刷新<br> XMLHttpRequest 对象<br>XMLHttpRequest 对象用于在后台与服务器交换数据。<br>创建一个xmlhttprequest对象<br>var xhr = new XMLHttpRequest();<br>同步和异步的区别<br>同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性。<br>同步：<br>浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。<br>异步：<br>浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。<br>JSON<br>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。<br>它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。<br>如：{“age”:”12″, “name”:”back”}<br>JSON字符串转换为JSON对象:<br>var obj =eval(‘(‘+ str +’)’);<br>var obj = str.parseJSON();<br>var obj = JSON.parse(str);<br>JSON对象转换为JSON字符串：<br>var last=obj.toJSONString();<br>var last=JSON.stringify(obj);</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="colin" />
          <p class="site-author-name" itemprop="name">colin</p>
           
              <p class="site-description motion-element" itemprop="description">孙涛的个人博客</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">Tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">colin</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
